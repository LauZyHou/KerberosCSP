/*
AS() = 收到Client的验证请求 -> 在KDC数据库中查找用户主体名称 -> if 找到匹配的项 then 获取主体私钥userKey -> 生成会话密钥sessionKey1和票证TGT1,用userKey加密为resp -> 向Client回复resp -> AS();
																else 回复错误消息 -> AS()

Client_Pre() = 向AS发送验证请求 -> 收到AS的resp -> if 正确消息 then 密钥解密resp拿到sessionKey1和TGT1 -> Client_Mid();
												else Client_Pre();

Client_Mid() = 向TGS发送请求(服务主体名称,TGT1,使用sessionKey1加密的验证者) -> 从TGS收消息 -> if 正确消息(即加密后的sessionKey2和TGT2) -> 解密 -> Client_Post();
																							  else Client_Pre();

TGS() = 收到Client的请求 ->  解密TGT1得到sessionKey1,再用sessionKey1解密得到验证者,再验证服务主体
				-> (if 成功验证 then 为用户主体和服务器生成sessionKey2,TGT2 -> 使用sessionKey1加密sessionKey2和TGT2 -> 回复这些信息给Client
				   else  回复错误消息) -> TGS();

Client_Post() = 向AppServ发送TGT2和用sessionKey2加密的验证者 -> 收到AppServ的信息 -> if 信息是允许访问 -> Client_Use();
																					 else -> Client_Pre();

Client_Use() = 向AppServ发送访问的具体信息 -> 接受来自AppServ访问的具体信息 -> if 不是错误信息 then Client_Use() else Stop;


AppServ() = [收到Client的验证信息(TGT2和验证者) -> 用sessionKey2解密 -> if 验证通过 then 回复通过 -> AppServ()] | [收到Client的访问信息 -> (if 已验证 then 回复访问信息 else 回复错误) -> AppServ()];

*/

//【通道声明】
//以下，通道'M_N'总是表征符号'_'左侧的进程'M'向右侧的进程'N'发消息的单工通道
channel C_AS 0;
channel AS_C 0;
channel C_TGS 0;
channel TGS_C 0;
channel C_App 0;
channel App_C 0;

//【其它】
//将sessionKey封装为TGS所需乘上的因子，这个知识被AS和TGS共享
#define sk2t 6;

/*
Client() = C_AS!msg -> AS_C?msg -> C_TGS!msg -> TGS_C?msg -> C_App!msg -> App_C?msg -> Skip;
AS() = C_AS?msg -> AS_C!msg -> AS();
TGS() = C_TGS?msg -> TGS_C!msg -> TGS();
AppServ() = C_App?msg -> App_C?msg -> AppServ();
*/


//==================================================================================

//【AS先验知识】
//数组的最小最大游标，这里用于模拟判断用户主体是否在数据库中
var min_uname = 0;
var max_uname = 5;
//使用数组模拟KDC数据库，下标表示uname，而相应的值表示ukey
var KDC_DB = [0..5];
//AS生成的sessionKey1明文
var sessionKey1 = 11;
//AS生成的票证TGT1明文，其中存储了sessionKey1的信息，也就是拿到TGT1可以解包得到sessionKey1
var TGT1 = sessionKey1*sk2t;

//【经与Client交互，得到的新知识】-1表示该知识尚未获取
//AS接收到的用户主体名称
var as_uname = -1;
//AS当前处理的用户的私钥
var as_ukey = -1;

//【AS进程定义】
AS() = C_AS?y { as_uname=y; } -> if(min_uname<=as_uname && as_uname<=max_uname) { //在数据库中找到了uname
                                     as_getukey { as_ukey=KDC_DB[as_uname]; } -> as_enc { TGT1=TGT1*as_ukey; sessionKey1=sessionKey1*as_ukey;  } -> AS_C!sessionKey1.TGT1 -> AS()
                                 } else { //在数据库中找不到uname
                                     AS_C!-1.-1 -> AS()
                                 };

//==================================================================================

//【Client先验知识】
//我的用户主体名称
var c_uname = 3;
//我的用户私钥
var c_ukey = 3;

//【经与AS交互，所得到的新知识】-1表示该知识尚未获取
var c_sessionKey1 = -1;
var c_TGT1 = -1;

//【与AS通信的Client子进程定义】
Client_Pre() = C_AS!c_uname -> AS_C?s.t { c_sessionKey1=s;c_TGT1=t; } -> if(c_sessionKey1!=-1 && c_TGT1!=-1 && c_ukey!=-1 && c_ukey==as_ukey) {
                                                                             cpre_dec { c_TGT1=c_TGT1/c_ukey; c_sessionKey1=c_sessionKey1/c_ukey; } -> Client_Mid()
                                                                         } else {
                                                                             Client_Pre()
                                                                         };

//==================================================================================

//【TGS先验知识】
//TGS接收到的用户主体名称
var tgt_uname = -1;
//TGS当前处理的用户的私钥
var tgt_ukey = -1;
//TGS生成的sessionKey2明文
var sessionKey2 = 22;
//TGS生成的票证TGT2明文，其中存储了sessionKey2的信息，也就是拿到TGT2可以解包得到sessionKey2
var TGT2 = sessionKey2*sk2t;

//另：TGS也能访问KDC数据库，即访问数组KDC_DB和变量min_uname,max_uname

//【TGS进程定义】
TGS() = Stop;//todo

//==================================================================================

//【为了与TGS通信，临时制造的知识】-1表示该知识尚未导出
//验证者1，使用Client1获取的sessionKey1对uname进行加密得来
var auth1 = -1;

//注：auth意为authenticator

//【与TGS通信的Client子进程定义】
Client_Mid() = gen_auth1 { auth1=c_uname*c_sessionKey1; } -> C_TGS!c_uname.c_TGT1.auth1 -> Stop;//todo



